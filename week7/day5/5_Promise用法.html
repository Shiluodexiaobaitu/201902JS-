<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            异步：
                事件轮询；
                宏任务: 定时器 ajax  Promise
                微任务： Promise 的 then  和 catch
                    宏任务中会包含一部分微任务，
                    先把宏任务中的微任务执行完毕之后才会去执行下一个宏任务
        */



        let p = new Promise(function (res,rej) {
            // console.log(333);
            // 该函数体是实参 该实参是同步执行的 
            // Promise 实例有三个状态  resolved  rejected  pending
            // 一开始 状态是pending 一旦改变，就不会再变动
            // 执行了成功函数 状态 由pending变成resolved
            // 执行了失败函数 状态 由pending变成rejected
            // 若既不执行成功函数 也不执行失败函数； 那么 状态一直是pending
            setTimeout(()=>{
                // console.log(1111)
                // res(123)
            },5000)
            // rej(666)
        });
        p.then((data)=>{
            console.log(data)
        },(err)=>{
            console.log(err);
        })
        // console.log(222);

        let p2 = new Promise(function(res,rej){
            // 当该函数执行失败的时候；会默认执行 rej;
            // res(123);
            console.log(abc);
        }).then((data)=>{
            console.log(data)
        },(err)=>{
            console.log(err);
            return 111
        }).then((data)=>{
            //该data 是上个then的回调函数的return值；
        },()=>{})


        /*
            function fn(f){
                f()
            }
            回调函数： 一个函数f被另外一个函数fn调用，我们把 f 称为 fn 的 回调函数；
        */
       // 异步： 事件，定时器 ajax, Promise,
       // 纯函数： 执行的时候对外界不会造成任何副作用的函数
       // 柯里化函数：一个函数 接收一个或者多个函数作为参数，返回一个新函数
       // 高阶函数：
       var f2 = a=>b=>c=>a+b+c;
       var f2 = function(a){
            return function(b){
                return function(c){
                    return a +b +c;
                }
            }
       }     
    </script>
</body>
</html>